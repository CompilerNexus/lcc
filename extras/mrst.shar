# To unbundle, sh this file
# Fri Aug  8 16:49:34 PDT 1997
echo README.mrst 1>&2
sed 's/^-//' >README.mrst <<'End of README.mrst'
-This version of lcc 4.0's src/stmt.c contains alternative
-switch-statement code generation functions for lcc, using Multiway
-Radix Search Trees (MRSTs). The method is described in detail in:
-
-Ulfar Erlingsson, Mukkai Krishnamoorthy and T.V. Raman.
-Efficient Multiway Radix Search Trees.
-Information Processing Letters 60, 3 (Nov. 11, 1996), 115-120.
-http://www.cs.cornell.edu/home/ulfar/mrst.ps.gz
-http://www.cs.princeton.edu/software/lcc/doc/mrst.pdf
-
-The code generated by the MRST method implemented usually has better
-performance than that generated by lcc's default method. The MRST
-method is especially appropriate if:
-
-1) The set of switch labels is large and sparse. The method works
-great on 1000 random 32-bit labels, for example.
-
-2) The run-time input to the switch is often not in the set of
-labels. In this case the MRST method usually breaks early.
-
-3) If i-cache performance is important.  The MRST method should bring
-in fewer cache lines since the generated tree is (almost) always of
-depth less than three.
-
-MRST sometimes does slightly worse than lcc's default method on inputs of
-size less than 16, when they are very sparse (e.g., the powers of two).
-
-I am very interested in hearing about any experiences people have using the
-MRST method, especially about empirical comparisons with lcc's method. Please
-email me at ulfar@cs.cornell.edu, or (more permanently) at ulfar@acm.org.
-
-USAGE: Replace src/stmt.c and src/inits.c with the enclosed files
-and rebuild lcc. To enable MRST method, use the -Wf-mrst option.
--Wf-msrt=N uses linear search for tables with N or fewer entries.
--Wf-mrst is equivalent to -Wf-mrst=4. Also, the -v option prints
-statistics for each switch statement on the standard error.
-
-To make the MRST method the default, change the initialization of
-mrst in src/stmt.c to N, e.g., 4.
-
-Ulfar Erlingsson / ulfar@cs.cornell.edu / ulfar@acm.org
-Thu Aug  7 15:40:19 PDT 1997
End of README.mrst
echo src/inits.c 1>&2
sed 's/^-//' >src/inits.c <<'End of src/inits.c'
-void init(int argc, char *argv[]) {
-	{extern void input_init(int, char *[]); input_init(argc, argv);}
-	{extern void main_init(int, char *[]); main_init(argc, argv);}
-	{extern void prof_init(int, char *[]); prof_init(argc, argv);}
-	{extern void stmt_init(int, char *[]); stmt_init(argc, argv);}
-	{extern void trace_init(int, char *[]); trace_init(argc, argv);}
-}
End of src/inits.c
echo src/stmt.c 1>&2
sed 's/^-//' >src/stmt.c <<'End of src/stmt.c'
-#line 2034 "book/stmt.nw"
-#include "c.h"
-
-static char rcsid[] = "$Id: stmt.nw,v 2.7.1.1 1997/08/08 23:41:31 drh Exp $";
-
-#line 928 "book/stmt.nw"
-#define SWSIZE 512
-
-#line 1246 "book/stmt.nw"
-#define den(i,j) ((j-buckets[i]+1.0)/(v[j]-v[buckets[i]]+1))
-
-#line 96 "book/stmt.nw"
-struct code codehead = { Start };
-Code codelist = &codehead;
-#line 1219 "book/stmt.nw"
-float density = 0.5;
-#line 2044 "book/stmt.nw"
-Table stmtlabs;
-
-#line 2148 "book/stmt.nw"
-static int mrst;        /* -mrst[=n] uses MRST for switches; <=n cases uses linear search */
-static int verbose;     /* -v emits information about switch statements */
-#line 2262 "book/stmt.nw"
-static int total_cases;
-static int total_steps;
-static int total_space;
-
-#line 1879 "book/stmt.nw"
-static int foldcond(Tree e1, Tree e2);
-#line 2136 "book/stmt.nw"
-static void caselabel(Swtch, long, int);
-static void cmp(int, Symbol, long, int);
-static Tree conditional(int);
-static void dostmt(int, Swtch, int);
-static int equal(Symbol, Symbol);
-static void forstmt(int, Swtch, int);
-static void ifstmt(int, int, Swtch, int);
-static Symbol localaddr(Tree);
-static void stmtlabel(void);
-static void swstmt(int, int, int);
-static void whilestmt(int, Swtch, int);
-#line 2384 "book/stmt.nw"
-static void mrst_swgen(Swtch);
-
-#line 107 "book/stmt.nw"
-Code code(int kind) {
-        Code cp;
-
-        
-#line 135 "book/stmt.nw"
-if (!reachable(kind))
-         warning("unreachable code\n");
-
-#line 111 "book/stmt.nw"
-        NEW(cp, FUNC);
-        cp->kind = kind;
-        cp->prev = codelist;
-        cp->next = NULL;
-        codelist->next = cp;
-        codelist = cp;
-        return cp;
-}
-#line 142 "book/stmt.nw"
-int reachable(int kind) {
-        Code cp;
-
-        if (kind > Start) {
-                Code cp;
-                for (cp = codelist; cp->kind < Label; )
-                        cp = cp->prev;
-                if (cp->kind == Jump || cp->kind == Switch)
-                        return 0;
-        }
-        return 1;
-}
-#line 164 "book/stmt.nw"
-void addlocal(Symbol p) {
-        if (!p->defined) {
-                code(Local)->u.var = p;
-                p->defined = 1;
-                p->scope = level;
-        }
-}
-#line 257 "book/stmt.nw"
-void definept(Coordinate *p) {
-        Code cp = code(Defpoint);
-
-        cp->u.point.src = p ? *p : src;
-        cp->u.point.point = npoints;
-        
-#line 269 "book/stmt.nw"
-if (ncalled > 0) {
-        int n = findcount(cp->u.point.src.file,
-                cp->u.point.src.x, cp->u.point.src.y);
-        if (n > 0)
-                refinc = (float)n/ncalled;
-}
-#line 263 "book/stmt.nw"
-        if (glevel > 2) locus(identifiers, &cp->u.point.src);
-        if (events.points)
-                
-#line 276 "book/stmt.nw"
-{
-        Tree e = NULL;
-        apply(events.points, &cp->u.point.src, &e);
-        if (e)
-                listnodes(e, 0, 0);
-}
-#line 266 "book/stmt.nw"
-}
-#line 299 "book/stmt.nw"
-void statement(int loop, Swtch swp, int lev) {
-        float ref = refinc;
-
-        if (Aflag >= 2 && lev == 15)
-                warning("more than 15 levels of nested statements\n");
-        switch (t) {
-        case IF:       
-#line 483 "book/stmt.nw"
-ifstmt(genlabel(2), loop, swp, lev + 1);
-
-#line 305 "book/stmt.nw"
-                                        break;
-        case WHILE:    
-#line 340 "book/stmt.nw"
-whilestmt(genlabel(3), swp, lev + 1);
-#line 306 "book/stmt.nw"
-                                           break;
-        case DO:       
-#line 338 "book/stmt.nw"
-dostmt(genlabel(3), swp, lev + 1);
-#line 307 "book/stmt.nw"
-                                        
-#line 326 "book/stmt.nw"
-expect(';');
-break;
-
-#line 308 "book/stmt.nw"
-        case FOR:      
-#line 709 "book/stmt.nw"
-forstmt(genlabel(4), swp, lev + 1);
-
-#line 308 "book/stmt.nw"
-                                         break;
-        case BREAK:    
-#line 905 "book/stmt.nw"
-walk(NULL, 0, 0);
-definept(NULL);
-if (swp && swp->lab > loop)
-        branch(swp->lab + 1);
-else if (loop)
-        branch(loop + 2);
-else
-        error("illegal break statement\n");
-t = gettok();
-#line 309 "book/stmt.nw"
-                                           
-#line 326 "book/stmt.nw"
-expect(';');
-break;
-
-#line 310 "book/stmt.nw"
-        case CONTINUE: 
-#line 678 "book/stmt.nw"
-walk(NULL, 0, 0);
-definept(NULL);
-if (loop)
-        branch(loop + 1);
-else
-        error("illegal continue statement\n");
-t = gettok();
-#line 310 "book/stmt.nw"
-                                              
-#line 326 "book/stmt.nw"
-expect(';');
-break;
-
-#line 311 "book/stmt.nw"
-        case SWITCH:   
-#line 925 "book/stmt.nw"
-swstmt(loop, genlabel(2), lev + 1);
-
-#line 311 "book/stmt.nw"
-                                            break;
-        case CASE:     
-#line 1002 "book/stmt.nw"
-{
-        int lab = genlabel(1);
-        if (swp == NULL)
-                error("illegal case label\n");
-        definelab(lab);
-        while (t == CASE) {
-                static char stop[] = { IF, ID, 0 };
-                Tree p;
-                t = gettok();
-                p = constexpr(0);
-                if (generic(p->op) == CNST && isint(p->type)) {
-                        if (swp) {
-                                needconst++;
-                                p = cast(p, swp->sym->type);
-                                if (p->type->op == UNSIGNED)
-                                        p->u.v.i = extend(p->u.v.u, p->type);
-                                needconst--;
-                                caselabel(swp, p->u.v.i, lab);
-                        }
-                } else
-                        error("case label must be a constant integer expression\n");
-
-                test(':', stop);
-        }
-        statement(loop, swp, lev);
-}
-#line 312 "book/stmt.nw"
-                                      break;
-        case DEFAULT:  
-#line 987 "book/stmt.nw"
-if (swp == NULL)
-        error("illegal default label\n");
-else if (swp->deflab)
-        error("extra default label\n");
-else {
-        swp->deflab = findlabel(swp->lab);
-        definelab(swp->deflab->u.l.label);
-}
-t = gettok();
-expect(':');
-statement(loop, swp, lev);
-#line 313 "book/stmt.nw"
-                                         break;
-        case RETURN:   
-#line 1514 "book/stmt.nw"
-{
-        Type rty = freturn(cfunc->type);
-        t = gettok();
-        definept(NULL);
-        if (t != ';')
-                if (rty == voidtype) {
-                        error("extraneous return value\n");
-                        expr(0);
-                        retcode(NULL);
-                } else
-                        retcode(expr(0));
-        else {
-                if (rty != voidtype)
-                        warning("missing return value\n");
-                retcode(NULL);
-        }
-        branch(cfunc->u.f.label);
-}
-#line 314 "book/stmt.nw"
-                                            
-#line 326 "book/stmt.nw"
-expect(';');
-break;
-
-#line 315 "book/stmt.nw"
-        case '{':      compound(loop, swp, lev + 1); break;
-        case ';':      definept(NULL); t = gettok(); break;
-        case GOTO:     
-#line 621 "book/stmt.nw"
-walk(NULL, 0, 0);
-definept(NULL);
-t = gettok();
-if (t == ID) {
-        Symbol p = lookup(token, stmtlabs);
-        
-#line 611 "book/stmt.nw"
-if (p == NULL) {
-        p = install(token, &stmtlabs, 0, FUNC);
-        p->scope = LABELS;
-        p->u.l.label = genlabel(1);
-        p->src = src;
-}
-#line 627 "book/stmt.nw"
-        use(p, src);
-        branch(p->u.l.label);
-        t = gettok();
-} else
-        error("missing label in goto\n");
-#line 317 "book/stmt.nw"
-                                          
-#line 326 "book/stmt.nw"
-expect(';');
-break;
-
-#line 318 "book/stmt.nw"
-        case ID:       
-#line 573 "book/stmt.nw"
-if (getchr() == ':') {
-        stmtlabel();
-        statement(loop, swp, lev);
-        break;
-}
-#line 319 "book/stmt.nw"
-        default:       
-#line 382 "book/stmt.nw"
-definept(NULL);
-if (kind[t] != ID) {
-        error("unrecognized statement\n");
-        t = gettok();
-} else {
-        Tree e = expr0(0);
-        listnodes(e, 0, 0);
-        if (nodecount == 0 || nodecount > 200)
-                walk(NULL, 0, 0);
-        else if (glevel) walk(NULL, 0, 0);
-        deallocate(STMT);
-}
-#line 319 "book/stmt.nw"
-                                                
-#line 326 "book/stmt.nw"
-expect(';');
-break;
-
-#line 320 "book/stmt.nw"
-        }
-        
-#line 330 "book/stmt.nw"
-if (kind[t] != IF && kind[t] != ID
-&& t != '}' && t != EOI) {
-        static char stop[] = { IF, ID, '}', 0 };
-        error("illegal statement termination\n");
-        skipto(0, stop);
-}
-#line 322 "book/stmt.nw"
-        refinc = ref;
-}
-
-#line 486 "book/stmt.nw"
-static void ifstmt(int lab, int loop, Swtch swp, int lev) {
-        t = gettok();
-        expect('(');
-        definept(NULL);
-        walk(conditional(')'), 0, lab);
-        refinc /= 2.0;
-        statement(loop, swp, lev);
-        if (t == ELSE) {
-                branch(lab + 1);
-                t = gettok();
-                definelab(lab);
-                statement(loop, swp, lev);
-                if (findlabel(lab + 1)->ref)
-                        definelab(lab + 1);
-        } else
-                definelab(lab);
-}
-#line 515 "book/stmt.nw"
-static Tree conditional(int tok) {
-        Tree p = expr(tok);
-
-        if (Aflag > 1 && isfunc(p->type))
-                warning("%s used in a conditional expression\n",
-                        funcname(p));
-        return cond(p);
-}
-#line 589 "book/stmt.nw"
-static void stmtlabel(void) {
-        Symbol p = lookup(token, stmtlabs);
-
-        
-#line 611 "book/stmt.nw"
-if (p == NULL) {
-        p = install(token, &stmtlabs, 0, FUNC);
-        p->scope = LABELS;
-        p->u.l.label = genlabel(1);
-        p->src = src;
-}
-#line 593 "book/stmt.nw"
-        if (p->defined)
-                error("redefinition of label `%s' previously defined at %w\n", p->name, &p->src);
-
-        p->defined = 1;
-        definelab(p->u.l.label);
-        t = gettok();
-        expect(':');
-}
-#line 712 "book/stmt.nw"
-static void forstmt(int lab, Swtch swp, int lev) {
-        int once = 0;
-        Tree e1 = NULL, e2 = NULL, e3 = NULL;
-        Coordinate pt2, pt3;
-        
-        t = gettok();
-        expect('(');
-        definept(NULL);
-        
-#line 724 "book/stmt.nw"
-if (kind[t] == ID)
-        e1 = texpr(expr0, ';', FUNC);
-else
-        expect(';');
-walk(e1, 0, 0);
-#line 735 "book/stmt.nw"
-pt2 = src;
-refinc *= 10.0;
-if (kind[t] == ID)
-        e2 = texpr(conditional, ';', FUNC);
-else
-        expect(';');
-#line 748 "book/stmt.nw"
-pt3 = src;
-if (kind[t] == ID)
-        e3 = texpr(expr0, ')', FUNC);
-else {
-        static char stop[] = { IF, ID, '}', 0 };
-        test(')', stop);
-}
-#line 773 "book/stmt.nw"
-if (e2) {
-        once = foldcond(e1, e2);
-        if (!once)
-                branch(lab + 3);
-}
-#line 787 "book/stmt.nw"
-definelab(lab);
-statement(lab, swp, lev);
-definelab(lab + 1);
-definept(&pt3);
-if (e3)
-        walk(e3, 0, 0);
-if (e2) {
-        if (!once)
-                definelab(lab + 3);
-        definept(&pt2);
-        walk(e2, lab, 0);
-} else {
-        definept(&pt2);
-        branch(lab);
-}
-if (findlabel(lab + 2)->ref)
-        definelab(lab + 2);
-#line 721 "book/stmt.nw"
-}
-#line 931 "book/stmt.nw"
-static void swstmt(int loop, int lab, int lev) {
-        Tree e;
-        struct swtch sw;
-        Code head, tail;
-
-        t = gettok();
-        expect('(');
-        definept(NULL);
-        e = expr(')');
-        
-#line 959 "book/stmt.nw"
-if (!isint(e->type)) {
-        error("illegal type `%t' in switch expression\n",
-                e->type);
-        e = retype(e, inttype);
-}
-e = cast(e, promote(e->type));
-#line 941 "book/stmt.nw"
-        
-#line 971 "book/stmt.nw"
-if (generic(e->op) == INDIR && isaddrop(e->kids[0]->op)
-&& e->kids[0]->u.sym->type == e->type
-&& !isvolatile(e->kids[0]->u.sym->type)) {
-        sw.sym = e->kids[0]->u.sym;
-        walk(NULL, 0, 0);
-} else {
-        sw.sym = genident(REGISTER, e->type, level);
-        addlocal(sw.sym);
-        walk(asgn(sw.sym, e), 0, 0);
-}
-#line 942 "book/stmt.nw"
-        head = code(Switch);
-        sw.lab = lab;
-        sw.deflab = NULL;
-        sw.ncases = 0;
-        sw.size = SWSIZE;
-        sw.values = newarray(SWSIZE, sizeof *sw.values, FUNC);
-        sw.labels = newarray(SWSIZE, sizeof *sw.labels, FUNC);
-        refinc /= 10.0;
-        statement(loop, &sw, lev);
-        
-#line 1091 "book/stmt.nw"
-if (sw.deflab == NULL) {
-        sw.deflab = findlabel(lab);
-        definelab(lab);
-        if (sw.ncases == 0)
-                warning("switch statement with no cases\n");
-}
-if (findlabel(lab + 1)->ref)
-        definelab(lab + 1);
-#line 952 "book/stmt.nw"
-        
-#line 1130 "book/stmt.nw"
-tail = codelist;
-codelist = head->prev;
-codelist->next = head->prev = NULL;
-#line 1140 "book/stmt.nw"
-if (sw.ncases > 0)
-        swgen(&sw);
-branch(lab);
-#line 1149 "book/stmt.nw"
-head->next->prev = codelist;
-codelist->next = head->next;
-codelist = tail;
-#line 953 "book/stmt.nw"
-}
-#line 1048 "book/stmt.nw"
-static void caselabel(Swtch swp, long val, int lab) {
-        int k;
-
-        if (swp->ncases >= swp->size)
-                
-#line 1068 "book/stmt.nw"
-{
-long   *vals = swp->values;
-Symbol *labs = swp->labels;
-swp->size *= 2;
-swp->values = newarray(swp->size, sizeof *swp->values, FUNC);
-swp->labels = newarray(swp->size, sizeof *swp->labels, FUNC);
-for (k = 0; k < swp->ncases; k++) {
-        swp->values[k] = vals[k];
-        swp->labels[k] = labs[k];
-}
-}
-#line 1053 "book/stmt.nw"
-        k = swp->ncases;
-        for ( ; k > 0 && swp->values[k-1] >= val; k--) {
-                swp->values[k] = swp->values[k-1];
-                swp->labels[k] = swp->labels[k-1];
-        }
-        if (k < swp->ncases && swp->values[k] == val)
-                error("duplicate case label `%d'\n", val);
-        swp->values[k] = val;
-        swp->labels[k] = findlabel(lab);
-        ++swp->ncases;
-        if (Aflag >= 2 && swp->ncases == 258)
-                warning("more than 257 cases in a switch\n");
-}
-#line 1249 "book/stmt.nw"
-void swgen(Swtch swp) {
-        int *buckets, k, n;
-        long *v = swp->values;
-
-        if (mrst) {
-                mrst_swgen(swp);
-                return;
-        }
-        buckets = newarray(swp->ncases + 1,
-                sizeof *buckets, FUNC);
-        for (n = k = 0; k < swp->ncases; k++, n++) {
-                buckets[n] = k;
-                while (n > 0 && den(n-1, k) >= density)
-                        n--;
-        }
-        buckets[n] = swp->ncases;
-        swcode(swp, buckets, 0, n - 1);
-}
-#line 1356 "book/stmt.nw"
-void swcode(Swtch swp, int b[], int lb, int ub) {
-        int hilab, lolab, l, u, k = (lb + ub)/2;
-        long *v = swp->values;
-
-        
-#line 1369 "book/stmt.nw"
-if (k > lb && k < ub) {
-        lolab = genlabel(1);
-        hilab = genlabel(1);
-} else if (k > lb) {
-        lolab = genlabel(1);
-        hilab = swp->deflab->u.l.label;
-} else if (k < ub) {
-        lolab = swp->deflab->u.l.label;
-        hilab = genlabel(1);
-} else
-        lolab = hilab = swp->deflab->u.l.label;
-#line 1392 "book/stmt.nw"
-l = b[k];
-u = b[k+1] - 1;
-if (u - l + 1 <= 3)
-        
-#line 1422 "book/stmt.nw"
-{
-        int i;
-        for (i = l; i <= u; i++)
-                cmp(EQ, swp->sym, v[i], swp->labels[i]->u.l.label);
-        if (k > lb && k < ub)
-                cmp(GT, swp->sym, v[u], hilab);
-        else if (k > lb)
-                cmp(GT, swp->sym, v[u], hilab);
-        else if (k < ub)
-                cmp(LT, swp->sym, v[l], lolab);
-        else
-                assert(lolab == hilab),
-                branch(lolab);
-        walk(NULL, 0, 0);
-}
-#line 1396 "book/stmt.nw"
-else {
-        
-#line 1453 "book/stmt.nw"
-Type ty = signedint(swp->sym->type);
-Symbol table = genident(STATIC,
-        array(voidptype, u - l + 1, 0), LABELS);
-(*IR->defsymbol)(table);
-cmp(LT, swp->sym, v[l], lolab);
-cmp(GT, swp->sym, v[u], hilab);
-walk(tree(JUMP, voidtype,
-        rvalue((*optree['+'])(ADD, pointer(idtree(table)),
-                (*optree['-'])(SUB,
-                        cast(idtree(swp->sym), ty),
-                        cnsttree(ty, v[l])))), NULL), 0, 0);
-#line 1496 "book/stmt.nw"
-code(Switch);
-codelist->u.swtch.table = table;
-codelist->u.swtch.sym = swp->sym;
-codelist->u.swtch.deflab = swp->deflab;
-codelist->u.swtch.size = u - l + 1;
-codelist->u.swtch.values = &v[l];
-codelist->u.swtch.labels = &swp->labels[l];
-if (v[u] - v[l] + 1 >= 10000)
-        warning("switch generates a huge table\n");
-#line 1398 "book/stmt.nw"
-}
-#line 1402 "book/stmt.nw"
-if (k > lb) {
-        assert(lolab != swp->deflab->u.l.label);
-        definelab(lolab);
-        swcode(swp, b, lb, k - 1);
-}
-if (k < ub) {
-        assert(hilab != swp->deflab->u.l.label);
-        definelab(hilab);
-        swcode(swp, b, k + 1, ub);
-}
-#line 1361 "book/stmt.nw"
-}
-#line 1472 "book/stmt.nw"
-static void cmp(int op, Symbol p, long n, int lab) {
-        listnodes(eqtree(op,
-                        idtree(p),
-                        cast(cnsttree(longtype, n), p->type)),
-                lab, 0);
-}
-#line 1563 "book/stmt.nw"
-void retcode(Tree p) {
-        Type ty;
-
-        if (p == NULL) {
-                if (events.returns)
-                        
-#line 1575 "book/stmt.nw"
-apply(events.returns, cfunc, NULL);
-#line 1569 "book/stmt.nw"
-                return;
-        }
-        
-#line 1589 "book/stmt.nw"
-p = pointer(p);
-ty = assign(freturn(cfunc->type), p);
-if (ty == NULL) {
-        error("illegal return type; found `%t' expected `%t'\n",
-                p->type, freturn(cfunc->type));
-        return;
-}
-p = cast(p, ty);
-#line 1605 "book/stmt.nw"
-if (retv)
-        
-#line 1652 "book/stmt.nw"
-{
-        if (iscallb(p))
-                p = tree(RIGHT, p->type,
-                        tree(CALL+B, p->type,
-                                p->kids[0]->kids[0], idtree(retv)),
-                        rvalue(idtree(retv)));
-        else
-                p = asgntree(ASGN, rvalue(idtree(retv)), p);
-        walk(p, 0, 0);
-        if (events.returns)
-                
-#line 1667 "book/stmt.nw"
-apply(events.returns, cfunc, rvalue(idtree(retv)));
-#line 1663 "book/stmt.nw"
-        return;
-}
-#line 1607 "book/stmt.nw"
-if (events.returns)
-        
-#line 1619 "book/stmt.nw"
-{
-        Symbol t1 = genident(AUTO, p->type, level);
-        addlocal(t1);
-        walk(asgn(t1, p), 0, 0);
-        apply(events.returns, cfunc, idtree(t1));
-        p = idtree(t1);
-}
-#line 1609 "book/stmt.nw"
-if (!isfloat(p->type))
-        p = cast(p, promote(p->type));
-if (isptr(p->type))
-        
-#line 1627 "book/stmt.nw"
-{
-        Symbol q = localaddr(p);
-        if (q && (q->computed || q->generated))
-                warning("pointer to a %s is an illegal return value\n",
-                        q->scope == PARAM ? "parameter" : "local");
-        else if (q)
-                warning("pointer to %s `%s' is an illegal return value\n",
-                        q->scope == PARAM ? "parameter" : "local", q->name);
-}
-#line 1613 "book/stmt.nw"
-walk(tree(mkop(RET,p->type), p->type, p, NULL), 0, 0);
-#line 1572 "book/stmt.nw"
-}
-#line 1694 "book/stmt.nw"
-void definelab(int lab) {
-        Code cp;
-        Symbol p = findlabel(lab);
-
-        assert(lab);
-        walk(NULL, 0, 0);
-        code(Label)->u.forest = newnode(LABEL+V, NULL, NULL, p);
-        for (cp = codelist->prev; cp->kind <= Label; )
-                cp = cp->prev;
-        while (
-#line 1719 "book/stmt.nw"
-   cp->kind == Jump
-&& cp->u.forest->kids[0]
-&& specific(cp->u.forest->kids[0]->op) == ADDRG+P
-&& cp->u.forest->kids[0]->syms[0] == p
-#line 1703 "book/stmt.nw"
-                                                         ) {
-                assert(cp->u.forest->kids[0]->syms[0]->u.l.label == lab);
-                p->ref--;
-                
-#line 1726 "book/stmt.nw"
-assert(cp->next);
-assert(cp->prev);
-cp->prev->next = cp->next;
-cp->next->prev = cp->prev;
-cp = cp->prev;
-#line 1707 "book/stmt.nw"
-                while (cp->kind <= Label)
-                        cp = cp->prev;
-        }
-}
-#line 1737 "book/stmt.nw"
-Node jump(int lab) {
-        Symbol p = findlabel(lab);
-
-        p->ref++;
-        return newnode(JUMP+V, newnode(ADDRG+ttob(voidptype), NULL, NULL, p),
-                NULL, NULL);
-}
-#line 1754 "book/stmt.nw"
-void branch(int lab) {
-        Code cp;
-        Symbol p = findlabel(lab);
-
-        assert(lab);
-        walk(NULL, 0, 0);
-        code(Label)->u.forest = jump(lab);
-        for (cp = codelist->prev; cp->kind < Label; )
-                cp = cp->prev;
-        while (
-#line 1782 "book/stmt.nw"
-   cp->kind == Label
-&& cp->u.forest->op == LABEL+V
-&& !equal(cp->u.forest->syms[0], p)
-#line 1763 "book/stmt.nw"
-                                                             ) {
-                equatelab(cp->u.forest->syms[0], p);
-                
-#line 1726 "book/stmt.nw"
-assert(cp->next);
-assert(cp->prev);
-cp->prev->next = cp->next;
-cp->next->prev = cp->prev;
-cp = cp->prev;
-#line 1766 "book/stmt.nw"
-                while (cp->kind < Label)
-                        cp = cp->prev;
-        }
-        
-#line 1830 "book/stmt.nw"
-if (cp->kind == Jump || cp->kind == Switch) {
-        p->ref--;
-        codelist->prev->next = NULL;
-        codelist = codelist->prev;
-} else {
-        codelist->kind = Jump;
-        if (cp->kind == Label
-        &&  cp->u.forest->op == LABEL+V
-        &&  equal(cp->u.forest->syms[0], p))
-                warning("source code specifies an infinite loop");
-}
-#line 1770 "book/stmt.nw"
-}
-#line 1789 "book/stmt.nw"
-void equatelab(Symbol old, Symbol new) {
-        assert(old->u.l.equatedto == NULL);
-        old->u.l.equatedto = new;
-        new->ref++;
-}
-#line 1817 "book/stmt.nw"
-static int equal(Symbol lprime, Symbol dst) {
-        assert(dst && lprime);
-        for ( ; dst; dst = dst->u.l.equatedto)
-                if (lprime == dst)
-                        return 1;
-        return 0;
-}
-#line 2047 "book/stmt.nw"
-/* dostmt - do statement while ( expression ) */
-static void dostmt(int lab, Swtch swp, int lev) {
-        refinc *= 10.0;
-        t = gettok();
-        definelab(lab);
-        statement(lab, swp, lev);
-        definelab(lab + 1);
-        expect(WHILE);
-        expect('(');
-        definept(NULL);
-        walk(conditional(')'), lab, 0);
-        if (findlabel(lab + 2)->ref)
-                definelab(lab + 2);
-}
-
-/* foldcond - check if initial test in for(e1;e2;e3) S is necessary */
-static int foldcond(Tree e1, Tree e2) {
-        int op = generic(e2->op);
-        Symbol v;
-
-        if (e1 == 0 || e2 == 0)
-                return 0;
-        if (generic(e1->op) == ASGN && isaddrop(e1->kids[0]->op)
-        && generic(e1->kids[1]->op) == CNST) {
-                v = e1->kids[0]->u.sym;
-                e1 = e1->kids[1];
-        } else
-                return 0;
-        if ((op==LE || op==LT || op==EQ || op==NE || op==GT || op==GE)
-        && generic(e2->kids[0]->op) == INDIR
-        && e2->kids[0]->kids[0]->u.sym == v
-        && e2->kids[1]->op == e1->op) {
-                e1 = simplify(op, e2->type, e1, e2->kids[1]);
-                if (e1->op == CNST+I)
-                        return e1->u.v.i;
-        }
-        return 0;
-}
-
-/* localaddr - returns q if p yields the address of local/parameter q; otherwise returns 0 */
-static Symbol localaddr(Tree p) {
-        if (p == NULL)
-                return NULL;
-        switch (generic(p->op)) {
-        case INDIR: case CALL: case ARG:
-                return NULL;
-        case ADDRL: case ADDRF:
-                return p->u.sym;
-        case RIGHT: case ASGN:
-                if (p->kids[1])
-                        return localaddr(p->kids[1]);
-                return localaddr(p->kids[0]);
-        case COND: {
-                Symbol q;
-                assert(p->kids[1] && p->kids[1]->op == RIGHT);
-                if ((q = localaddr(p->kids[1]->kids[0])) != NULL)
-                        return q;
-                return localaddr(p->kids[1]->kids[1]);
-                }
-        default: {
-                Symbol q;
-                if (p->kids[0] && (q = localaddr(p->kids[0])) != NULL)
-                        return q;
-                return localaddr(p->kids[1]);
-                }
-        }
-}
-
-/* whilestmt - while ( expression ) statement */
-static void whilestmt(int lab, Swtch swp, int lev) {
-        Coordinate pt;
-        Tree e;
-
-        refinc *= 10.0;
-        t = gettok();
-        expect('(');
-        walk(NULL, 0, 0);
-        pt = src;
-        e = texpr(conditional, ')', FUNC);
-        branch(lab + 1);
-        definelab(lab);
-        statement(lab, swp, lev);
-        definelab(lab + 1);
-        definept(&pt);
-        walk(e, lab, 0);
-        if (findlabel(lab + 2)->ref)
-                definelab(lab + 2);
-}
-#line 2151 "book/stmt.nw"
-/*
-Alternative switch-statement code generation functions using
-Multiway Radix Search Trees (MRSTs). For details, see:
-
-Ulfar Erlingsson, Mukkai Krishnamoorthy and T. V. Raman.
-Efficient Multiway Radix Search Trees.
-Information Processing Letters 60, 3 (Nov. 11, 1996), 115-120.
-http://www.cs.cornell.edu/home/ulfar/mrst.ps.gz
-http://www.cs.princeton.edu/software/lcc/doc/mrst.pdf
-
-Ulfar Erlingson, August 1997.
-*/
-
-static unsigned int Cardinality(Swtch swp, unsigned long W, int L, int lowbit) {
-  if( W == 0 )
-    return 0;
-  {
-    unsigned int tblsize = (1u << L);
-    char* vals = newarray(tblsize, sizeof(char), FUNC);
-    long* v = swp->values;
-    int i, cnt = 0;
-    memset(vals, 0, tblsize*sizeof *vals);
-    for( i = 0; i < swp->ncases; ++i ) {
-      int index = (((v[i]) & W) >> lowbit);
-      if( vals[index] == 0 )
-        ++cnt;
-      vals[index] = 1;
-    }
-    return cnt;
-  }
-}
-
-static int Critical(Swtch swp, unsigned long W, int L, int lowbit) {
-  unsigned int tblsize = (1u << L);
-  assert(tblsize > 0);
-  if( (1.0/density)*Cardinality(swp,W,L,lowbit) > tblsize )
-    return 1;
-  return 0;
-}
-
-static unsigned int mrst_find_window(Swtch swp, int *len, int *lowbit) {
-  unsigned long W = 0, Wmax = 0;
-  unsigned int C = 0, Cmax = 0;
-  unsigned long Wleft = 0;
-  int L = 0, Lmax = 0;
-  int lowmax = 0;
-
-  int no_b = (CHAR_BIT*sizeof(unsigned long)-1);
-  unsigned long b = 1LU << no_b;
-  for( ; b > 0; b >>= 1 )
-  {
-    if( W == 0 ) Wleft = b;
-    W |= b; 
-    L += 1; 
-
-    if( Critical(swp, W, L, no_b) ) {
-      Wmax = W;
-      Lmax = L;
-      lowmax = no_b;
-      Cmax = Cardinality(swp, Wmax, Lmax, lowmax);
-    }
-
-    else {
-      unsigned int C;
-      assert( (W & Wleft) != 0 ); 
-      W ^= Wleft;
-      Wleft >>= 1;
-      L -= 1;
-
-      C = Cardinality(swp, W, L, no_b);
-      if( C > Cmax ) {
-        Wmax = W;
-        Lmax = L;
-        lowmax = no_b;
-        Cmax = C;
-      }
-    }
-    --no_b;
-  }
-  assert(Lmax > 0);
-  *len = Lmax;
-  *lowbit = lowmax;
-  return Wmax;
-}
-
-static int EntryUsed(Swtch swp, int j, unsigned long Wmax, int lowbit) {
-  int i;
-  long* v = swp->values;
-  unsigned long mask = Wmax >> lowbit;
-  for( i = 0; i < swp->ncases; ++i ) {
-    if( ((((unsigned long)v[i]) >> lowbit)&mask) == j )
-      return 1;
-  }
-  return 0;
-}
-
-static void GetEntries(Swtch swp, Swtch rec, int j, unsigned long Wmax, int lowbit) {
-  int i, k;
-  long* v = swp->values;
-  unsigned long mask = Wmax >> lowbit;
-  for( i = k = 0; i < swp->ncases; ++i ) {
-    if( ((((unsigned long)v[i]) >> lowbit)&mask) == j ) {
-      rec->values[k] = v[i];
-      rec->labels[k] = swp->labels[i];
-      ++k;
-    }
-  }
-  rec->ncases = k;
-}
-
-#line 2267 "book/stmt.nw"
-static void mrst_swgen_rec(Swtch swp, int steps) {
-  long *v = swp->values;
-  Symbol *labs = swp->labels;
-
-  /*
-  ** Step 1: Handle small switches with comparisons
-  */
-  if (swp->ncases <= mrst)
-  {
-     int i;
-     for( i = 0; i < swp->ncases; ++i ) {
-       cmp(EQ, swp->sym, v[i], labs[i]->u.l.label);
-       total_steps += steps + i + 1;
-     }
-     branch(swp->deflab->u.l.label);
-     total_cases += swp->ncases; 
-     return;
-  }
-
-  {
-    /*
-    ** Step 2: Find the maximum window
-    */
-    int len, lowbit;
-    unsigned long Wmax = mrst_find_window(swp, &len, &lowbit);
-    unsigned int tblsize = (1u << len);
-    int shiftbits = lowbit;
-    Tree shifttree;
-
-    /*
-    ** Step 3: Generate the assignment of val(z,Wmax) and jump
-    */
-    Type ty = swp->sym->type;
-    long *values = newarray(tblsize, sizeof(*values), FUNC);
-    Symbol *labels = newarray(tblsize, sizeof(*labels), FUNC);
-    int tbllab = genlabel(tblsize);
-    assert(len > 0 && tblsize > 0);
-    if (swp->sym->type == inttype)
-        ty = unsignedtype;
-    else if (swp->sym->type == longtype)
-        ty = unsignedlong;
-    else
-        ty = swp->sym->type;    /* it's already and unsigned type */
-    if( tblsize == 2 )
-    {
-      listnodes(eqtree(EQ,
-                       bittree(BAND,
-                               cast(idtree(swp->sym), ty),
-                               cnsttree(ty, Wmax)),
-                       cnsttree(ty, 0)),
-                tbllab, 0);
-      branch(tbllab + 1);
-    }
-    else /* tblsize > 2 */
-    {
-      Symbol table = genident(STATIC, array(voidptype, tblsize, 0), LABELS);
-      (*IR->defsymbol)(table);
-      shifttree = shtree(RSH,
-                         cast(idtree(swp->sym), ty),
-                         cnsttree(inttype, shiftbits));
-      walk(tree(JUMP, voidtype,
-                rvalue((*optree['+'])(ADD,
-                                      pointer(idtree(table)),
-                                      bittree(BAND, 
-                                              shifttree,
-                                              cnsttree(unsignedtype, Wmax>>shiftbits)))),
-                NULL),
-           0,0);
-      code(Switch);
-      codelist->u.swtch.table = table;
-      codelist->u.swtch.sym = swp->sym;
-      codelist->u.swtch.deflab = swp->deflab;
-      codelist->u.swtch.size = tblsize;
-      codelist->u.swtch.values = values;
-      codelist->u.swtch.labels = labels;
-      if (tblsize >= 10000)
-        warning("switch generates a huge table\n");
-    }
-
-    /*
-    ** Step 4: Generate the table
-    */
-    total_space += tblsize;
-    {
-      unsigned int j;
-      for( j = 0; j < tblsize; ++j ) {
-        values[j] = j;
-        if( EntryUsed(swp, j, Wmax, lowbit) )
-          labels[j] = findlabel(tbllab + j);
-        else
-          labels[j] = swp->deflab;
-      }
-    }
-
-    /*
-    ** Step 5: Recurse
-    */
-    {
-      unsigned int j;
-      struct swtch rec;
-      rec.values = newarray(swp->ncases, sizeof rec.values, FUNC);
-      rec.labels = newarray(swp->ncases, sizeof rec.labels, FUNC);
-      rec.sym = swp->sym;
-      rec.deflab = swp->deflab;
-
-      for( j = 0; j < tblsize; ++j ) 
-        if( labels[j] != swp->deflab ) {
-          rec.lab = tbllab + j;
-          definelab(rec.lab);
-          GetEntries( swp, &rec, j, Wmax, lowbit );
-          mrst_swgen_rec(&rec, steps+1);
-        }
-    }
-  }
-}
-
-#line 2387 "book/stmt.nw"
-static void mrst_swgen(Swtch swp) {
-  total_cases = 0;
-  total_steps = 0;
-  total_space = swp->ncases;
-  mrst_swgen_rec(swp, 0);
-  if (verbose) {
-        fprint(stderr, "MRST switch\n" );
-        fprint(stderr, " -- Cases: %d\n", total_cases);
-        fprint(stderr, " -- Space: %d\n", total_space);
-        fprint(stderr, " -- Total branches: %d\n", total_steps);
-        fprint(stderr, " -- Avg. branches: %f\n", (float)total_steps/total_cases);
-  }
-}
-
-void stmt_init(int argc, char *argv[]) {
-        int i;
-        static int inited;
-
-        if (inited)
-                return;
-        inited = 1;
-        for (i = 1; i < argc; i++)
-                if (strncmp(argv[i], "-mrst=", 6) == 0)
-                        mrst = atoi(argv[i]+6);
-                else if (strcmp(argv[i], "-mrst") == 0)
-                        mrst = 4;               /* default threshold */
-                else if (strcmp(argv[i], "-v") == 0)
-                        verbose++;
-}
End of src/stmt.c
